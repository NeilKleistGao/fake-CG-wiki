## AABB
由于场景中可能有大量的三角形网格，每发射出一根光线就遍历所有的三角形并判断是否求交是不现实的。
为此，我们需要轴对齐包围盒（Axis-Aligned Bounding Box， AABB）来进行优化。

对于每一个物体，我们创建一个AABB，创建的依据是物体表面顶点在x,y,z轴上的最大值和最小值。根据这6个值，我们可以创建出一个立方体。
该立方体的边是与x/y/z轴是平行的。此时如果光线与该包围盒不相交，那里面的三角形就更不可能与光线相交；反之，我们在判断光线与其中每一个三角形的相交情况。

![Screenshot from 2021-11-28 12-03-26.png](https://i.loli.net/2021/11/28/64ihHeXkLcu97JU.png)

以 $\triangle ABC$ 为例，我们可以画出它的AABB：

![Screenshot from 2021-11-28 12-05-40.png](https://i.loli.net/2021/11/28/oSNMPUBtCRhd1py.png)

在计算光线与 $\triangle ABC$ 求交之前，我们会优先计算四边形 $DECF$ 与光线求交。如果光线不会和四边形产生交点，那我们就可以忽略里面的内容。

光线与AABB求交比起光线与三角形或其他隐式表面求交要容易的多。首先，由于包围盒本身是轴对齐的，我们不妨认为这个包围盒是四条直线围成的区域（3D下则是平面）：

![Screenshot from 2021-11-28 12-16-54.png](https://i.loli.net/2021/11/28/rKAPTXQiHnfRB2Z.png)

任何一条光线都至少会与一组平行的直线相交，并产生两个交点。我们可以很容易地记录下交点对应的 $t$ 的值：

![Screenshot from 2021-11-28 12-20-26.png](https://i.loli.net/2021/11/28/eRlH7P2cQNdCIUr.png)

其中， $t_1, t_2$ 是进入平行线的时间，而 $t_3, t_4$ 是离开平行线的时间。我们记录下 $t_{enter} = max{t_1, t_2}$ 和 $t_{exit} = min{t_3, t_4}$ ，
其中 $t_{enter}$ 表示进入 $AB$ 右侧， $BC$ 上侧的时间； $t_{exit}$ 表示离开 $AD$ 下侧， $CD$ 左侧区域的时间。我们将二者取一个交集，
我们就可以得到进入和离开 $ABCD$ 的时间。只要满足 $t_{enter} < t_{exit}$ ，就说明光线穿过了这个AABB。

如果 $t_{enter}$ 为负，则说明光线需要向后延伸，才能碰到包围盒的边界，这表示光源本身在包围盒内；但如果 $t_{exit}$ 也为负，则说明整个包围盒完全在光线的后面。
此外，如果光线与轴也平行，那我们只能得到一组 $t_{enter}, t_{exit}$ 且他们一定满足 $t_{enter} < t_{exit}$ 。此时我们需要特殊判断。
 
在这个例子中我们看不到任何“优化”的迹象，这是因为这个AABB内只有一个三角形。如果这个AABB内是一个拥有成千上万个三角形的网格，效果就会非常明显。

## 空间划分结构
### 四叉树和八叉树
我们喜欢二叉搜索树，这样的结构使得我们每次只需要检索一半的内容（如果树本身是平衡的话）。在空间中，我们也可以使用四叉树（二维空间）或八叉树（三维空间）来进行划分：

![Screenshot from 2021-11-28 12-50-05.png](https://i.loli.net/2021/11/28/24JbVq9XHQc3ejy.png)

如图，我们将二维平面划分为4个区域，以此保证每个区域内的元素个数不会超过一定的阈值（本图中是2）。
如果当前区域中仍然有过多的物体，我们就再次细分为四个区域，直到每个区域都满足条件。

我们只在最终的叶子节点处存储物体的具体信息，在非叶子节点中，我们仅保留当前区域的范围。当我们射出一条光线时，我们会在这棵树中进行查找。
如果光线与当前节点的区域发生了碰撞（和AABB一样的方法检测），那么我们就继续遍历其子节点。如果该节点是叶子节点，我们再对其中的物体逐个进行求交判断。

### KD树
KD树比起四叉树/八叉树来说更加灵活，它只是一颗二叉树。在进行空间划分的过程中，我们每次只选择一个维度进行划分：

![Screenshot from 2021-11-28 16-12-46.png](https://i.loli.net/2021/11/28/DtOWUApleR6mid7.png)

在该场景中，我们首先选择垂直方向进行划分。由于划分后左半区依然不满足阈值要求，我们需要进行第二次划分。第二次划分与第一次不同，我们需要从水平方向进行。
这个步骤一直重复，直到每个区域内的点的数量都小于给定的要求。

相比四叉树/八叉树，我们划分的选择可以更加灵活，不需要局限在中心位置，而是可以自由指定。如果找到一个不错的位置，就可以节约划分次数。
与四叉树/八叉树相同，我们仅在叶子节点保存物体的详细数据。

### BSP树
BSP树是KD树更灵活的版本。KD树在划分的过程中，每次所选择的轴依然需要和坐标系对齐，而BSP树则没有这个限制，所以可以得到更灵活的划分。

## BVH
层次包围盒（Bounding Volume Hierarchies，BVH）不同于之前提到的基于空间的划分结构，这是一种基于物体本身的划分结构（图片来自于GAMES101）：

![Screenshot from 2021-11-28 16-26-37.png](https://i.loli.net/2021/11/28/q9l5DTpGvX1LrVk.png)

在最开始的时候，我们给定所有的物体一个大的包围盒，然后再在这个大的包围盒的基础上进行划分，将其变为更小的两个包围盒。
重复这个步骤，直到每个包围盒足够小，或者包围盒内的物体数量低于给定阈值为止。
划分的依据可以有很多，比如每次选择最长的一条轴进行划分，每次选择当前轴的中位数进行划分等等。

与空间划分结构相同，我们只在叶子节点保存物体的数据，而非叶子节点仅保存有包围盒数据。在判断光线与物体求交时，我们也采取和空间划分结构相似的方法。

| 特性 | 空间划分 | 物体划分 |
| --- | ------- | ------ |
| 包围盒是否重叠 | 不重叠 | 重叠 |
| 物体数据保存 | 可能在多个叶子节点 | 仅在一个叶子节点 |



## 参考资料
+ [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744?p=14)