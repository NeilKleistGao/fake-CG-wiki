## 画家算法
在绘制图元的时候，我们常常需要考虑一个问题：究竟谁应该被放在前面（遮挡），谁应该被放在后面（被遮挡）。最早的算法是从油画家身上借鉴过来的。

在绘制图像的时候，我们先绘制远景，再绘制近景，问题就可以迎刃而解。比如我们在绘制风景画的时候，先绘制远处的山，再绘制近处的地，最后再画距离最近的树（以下图片均来自于GAMES101，详见参考资料）：

![Screenshot from 2021-10-24 21-29-13.png](https://i.loli.net/2021/10/24/59vgchOAuICxQjM.png)

这样的方法可以解决大部分的问题，比如2D场景的渲染。但是对于特殊的3D场景，这个算法会出现问题：

![Screenshot from 2021-10-24 21-31-04.png](https://i.loli.net/2021/10/24/ybP147s8NnFdIvt.png)

此时的三维场景中存在着三个三角形。由于现在我们讨论的是空间而不是平面，这些三角形可以互相遮挡，从而形成一个环。我们无法判断出来谁在最上面，因而画家算法会导致错误。

## 深度缓存
为了处理这样的情况，人们提出了深度缓存。除了我们最终写入的图像缓存外，我们还将记录每个位置对应的最小深度值：

![Screenshot from 2021-10-24 21-34-21.png](https://i.loli.net/2021/10/24/IvV6RjizlBYaGEH.png)

现在，我们渲染的流程如下：

+ 初始化深度缓存，所有的值为无穷大
+ 当我们需要向图像缓存写入的时候，先读取这个位置上的最小深度值
+ 如果当前这个像素的深度值更小，那么我们更新最小深度值，并把这个像素写入到图像缓存中
+ 否则，我们认为这个像素前面已经有其他像素把它挡住了，我们需要丢弃它

在OpenGL中，深度缓存默认是关闭的，我们可以这样开启深度缓存：
```c++
glEnable(GL_DEPTH_TEST);
```

并且在每一帧更新的时候进行清空操作：
```c++
glClear(GL_DEPTH_BUFFER_BIT);
```

此外，我们可以指定深度测试函数：
```c++
glDepthFunc(FUNC);
```

其中，`FUNC`只能指定为如下的值：

| 函数 | 说明 |
| --- | --- |
| GL_ALWAYS | 永远可以通过深度测试，这和禁用深度缓存是一样的 |
| GL_NEVER | 永远无法通过深度测试 |
| GL_LESS | 当前深度值小于缓存内的值时可以通过测试 |
| GL_EQUAL | 当前深度值等于缓存内的值时可以通过测试 |
| GL_LEQUAL | 当前深度值小于等于缓存内的值时可以通过测试 |
| GL_GREATER | 当前深度值大于缓存内的值时可以通过测试 |
| GL_NOTEQUAL | 当前深度值不等于缓存内的值时可以通过测试 |
| GL_GEQUAL | 当前深度值大于等于缓存内的值时可以通过测试 |

## 深度冲突
由于我们的深度是一个0到1的浮点数，所以我们所保存的深度值是会有精度损失的。
这意味着两个像素的深度值原本应该是一样的，但是由于精度不足，导致我们无法决定究竟应该把哪一个像素放在前面（以下图片来自于LearnOpenGL CN，详见参考资料）：

![](https://learnopengl-cn.github.io/img/04/01/depth_testing_z_fighting.png)

为了解决这样的问题，我们通常会去增大深度的精度值。虽然让两个物体不要靠的过近也可以解决问题，但是并不能保证这样的情况不会发生。

## 参考资料
+ [GAMES101-现代计算机图形学入门-闫令琪](https://www.bilibili.com/video/BV1X7411F744?p=7)
+ [深度测试](https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/01%20Depth%20testing/)