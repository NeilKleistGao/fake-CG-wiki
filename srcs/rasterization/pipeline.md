## 什么是渲染管线
渲染管线（渲染流水线， Rendering Pipeline）包含一系列的处理流程。它从一个三维场景出发，生成出一张二维的图像。
你可以类比工厂中的流水线，加工一盒牛奶可能需要如下的步骤：

+ 挤牛奶
+ 消毒
+ 包装
+ 放入仓库存储

这些步骤就可以组成一条牛奶生产的流水线，并且所有操作都可以同时进行，保证了生产的高效。
同理，渲染管线也包含了一些必备的步骤：

+ 应用阶段
+ 几何阶段
+ 光栅化阶段

### 应用阶段
在应用阶段起主导作用的依然是CPU而不是GPU。在这个阶段中，CPU将模型数据/贴图/场景数据等读入到内存，然后将这些内容传递给GPU。
这个阶段可能还会涉及一些预处理。

### 几何阶段
几何阶段主要决定所需要绘制的图元，以及其绘制的位置和细节。
几何阶段的一个重要任务是将顶点坐标从模型空间变换到屏幕空间，之后管线会确定输出的图元类型（三角形？四边形？还是其他形状？），并将这些数据传递给下一阶段。

### 光栅化阶段
光栅化阶段是具体决定“图元该如何表现在屏幕上”的阶段。管线在这个阶段会决定哪些像素需要绘制，怎么绘制，是使用颜色，还是用纹理。
这个阶段还会涉及到一些测试和混合的内容。

接下来我们以OpenGL的渲染管线为例，详细讲解每一个步骤。

## OpenGL渲染管线结构
先放一张来自于Learn OpenGL的经典管线结构图：

![](https://learnopengl-cn.github.io/img/01/04/pipeline.png)

这就是OpenGL管线的基本结构。其中顶点数据来自应用阶段，第一行代表了几何阶段，而第二行代表了光栅化阶段。

### 应用阶段与Draw Call
OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。
在应用阶段，我们需要通过API去修改OpenGL的上下文，从而完成不同的渲染任务。每次设置完上下文，调用渲染指令的过程，被称为一次Draw Call。

过多的Draw Call会严重影响性能。但这并不是由于Draw Call本身造成的，而是由于上下文频繁地切换导致的。之后的内容中我们将提到如何对Draw Call进行优化。

### 顶点着色器
顶点着色器以顶点数据为输入，输出对应的三维坐标。在顶点着色器中，一项重要的任务就是将坐标从模型空间转换为屏幕空间。除此以外，顶点着色器还可以对法线以及uv坐标进行处理。

一个典型的OpenGL顶点着色器大致如下：
```s
#version 330 core
layout (location=0) in vec3 position;
layout (location=1) in vec3 color;
layout (location=2) in vec2 tex_coord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 project;

out vec3 color_mask;
out vec2 tc;

void main() {
    color_mask = color;
    tc = tex_coord;
    gl_Position = project * view * model * vec4(position.xyz, 1.0);
}

```

该着色器接受一个顶点的坐标数据（连带的还有颜色和纹理坐标），并根据指定的矩阵进行坐标变换，变换后的结果被传递给下一个阶段。

### 图元装配
图元装配需要决定输入的顶点数据应该被组装为什么图元。
例如输入的顶点数据为 $(0, 0) (1, 0) (1, 1) (0, 1)$ ，这既可以表示一个矩形，也可以拆分开来认为是两条直线。
OpenGL会根据上下文决定当前顶点的组装方式。

### 几何着色器
几何着色器是OpenGL中的一个可选着色器。它以一个图元为输入，经过一系列的变换，输出另一个图元。
如果不使用几何着色器，图元数据会直接进入光栅化阶段。

### 光栅化
光栅化阶段会确定屏幕中的哪些像素被当前图元覆盖，从而需要被渲染。所有需要渲染的像素会被传入到片段着色器中进行进一步的处理。
在光栅化阶段，超出视图范围的部分会被裁切掉，从而减少片段着色器的调用次数，从而提高效率。光栅化阶段还需要根据图元进行一些插值操作。

### 片段着色器
片段着色器（也叫片元着色器）决定了某一个片段（片元，像素）的绘制方式。你可以根据位置、光照、纹理坐标等属性决定该像素的颜色。

以下是一个OpenGL片段着色器的例子：
```s
#version 330 core

in vec3 color_mask;
in vec2 tc;
out vec4 frag_color;

uniform sampler2D text;

void main() {
    frag_color = vec4(color_mask.rgb, 1.0) * texture(text, tc);
}
```

该着色器根据用户提供的颜色遮罩以及纹理数据，输出了相应像素的颜色。

### 测试与混合
确定好颜色的像素依然不能直接绘制！一个亟需考虑的问题是像素间的遮挡关系。如果一个像素被另一个像素所遮挡，那么这个像素就不该被绘制。
判断像素遮挡关系需要进行深度测试。此外，用户还可以指定一系列的模板测试，以实现更加复杂的效果。

为了实现半透明的效果，管线还需要拥有能力将前景色和背景色进行混合。

通过测试完成混合后，像素才会真正地被显示在屏幕上。

## 其他的渲染管线
渲染管线的实现不是唯一的。我们会补充一些其他的渲染管线作为说明。

### 固定渲染管线
固定渲染管线是早期OpenGL所采取的解决方案。顾名思义，固定渲染管线给予用户的自由度更低，但操作更加简洁方便。
固定渲染管线也不是可编程的，即你无法为你的渲染管线指定你自己所编写的着色器。

### Unity3D的渲染管线
Unity提供了不同的渲染管线以供用户使用，你甚至可以编写自己的渲染管线。

Unity3D内置的渲染管线也是不可编程的，用户只能通过配置不同的渲染路径来实现不同的效果。此外，Unity3D还提供了通用渲染管线(URP)和高清渲染管线(HDRP)。
这些渲染管线都是可编程的，并且能提供更好的渲染效果。高清渲染管线甚至使用了基于物理的材质和光照，但对应的需要硬件提供支持。

## 参考资料
+ 《Unity Shader入门精要》 冯乐乐
+ [Learn OpenGL CN](https://learnopengl-cn.github.io/)
+ [Unity手册 渲染管线](https://docs.unity.cn/cn/2021.1/Manual/render-pipelines.html)